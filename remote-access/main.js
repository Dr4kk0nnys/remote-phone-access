"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
/*
    * TODO: The creator of scrcpy gave me a great tip on how to find the ip address
    * using: "adb shell netcfg" or "adb shell ip a", I will look into it
*/
class Main {
    constructor() {
        /*
            * port can be passed as an argument through the command line
            * PORT=1234 node main.js
            *
            * Also: The default port of adb is 5555, so if no port is passed
            * on the terminal, it will just be 5555.
        */
        this.PORT = process.env.PORT || 5555;
        this.execPromise = util.promisify(child_process_1.exec);
        this.readFilePromise = util.promisify(fs_1.readFile);
        console.log(`Remote access called at: ${new Date()}\n`);
    }
    async getSanitizedIpAddresses() {
        try {
            /*
                * DOCUMENTATION: 'https://angryip.org/documentation/'

                * [options] <feeder> <exporter>

                Where <feeder> is one of:
                -f:range <Start IP> <End IP>
                -f:random <Base IP> <IP Mask> <Count>
                -f:file <File>

                <exporter> is one of:
                -o filename.txt         Text file (txt)
                -o filename.csv         Comma-separated file (csv)
                -o filename.xml         XML file (xml)
                -o filename.lst         IP:Port list (lst)

                And possible [options] are (grouping allowed):
                -s      start scanning automatically
                -q      quit after exporting the results
                -a      append to the file, do not overwrite
            */
            // change the path for your system
            const pathToFile = './scan.txt';
            /*
                * This line will execute the scan with the ip range of:
                    * 10.0.0.0 to 10.0.0.255 ( it will look for the entire network )
                * the -f flag specifies the network range
                * the -s flag means the scan will start automatically
                * the -o flag specifies the path to save the output
                * the -q flag means the program should close automatically after the scan is done
                *
                * the file is exported to 'scan.txt' inside this directory
                * which will be later read by the readFile function
            */
            await this.execPromise(`ipscan -f:range 10.0.0.0 10.0.0.255 -s -o ${pathToFile} -q`);
            /*
                * The scan file should look something like this:

                Generated by Angry IP Scanner 3.7.2
                https://angryip.org

                Scanned 10.0.0.0 - 10.0.0.255
                23 de ago de 2020 10:31:09

                IP              Ping            Hostname                Ports
                10.0.0.1        0 ms            _gateway                80
                10.0.0.117      0 ms            230                     [n/a]
                10.0.0.125      338 ms          Android.local           [n/a]
                10.0.0.129      78 ms           [n/a]                   [n/a]
                10.0.0.169      2 ms            [n/a]                   [n/a]
                10.0.0.190      42 ms           [n/a]                   [n/a]

                * So there is quite a lot of cleaning and sanitizing to do.
            */
            const scanFile = await this.readFile(pathToFile);
            console.log(scanFile);
            const ipsInfo = scanFile.split('\n').filter(element => element.startsWith('10.0.0.'));
            /*
                * IpInfo should look something like this

                '10.0.0.1        0 ms            _gateway                80              ',
                '10.0.0.117      0 ms            230                     [n/a]           ',
                '10.0.0.169      37 ms           [n/a]                   [n/a]           '
            */
            const sanitizedIPS = ipsInfo.map(element => element.split(' ')[0]);
            /*
                * sanitizedIPS: ['10.0.0.1', '10.0.0.117', '10.0.0.169']
            */
            return sanitizedIPS;
        }
        catch (error) {
            console.error(error);
        }
    }
    async readFile(path) {
        try {
            const file = await this.readFilePromise(path, 'utf8');
            return file;
        }
        catch (error) {
            throw error;
        }
    }
    async tryConnectionWithIpAddresses(sanitizedIpAddresses) {
        try {
            for (let i = 0; i < sanitizedIpAddresses.length; i++) {
                const ip = sanitizedIpAddresses[i];
                const { stdout } = await this.execPromise(`adb connect ${ip}:${this.PORT}`);
                if (stdout.startsWith('connected'))
                    return true;
            }
            return false;
        }
        catch (error) {
            console.error(error);
        }
    }
    async runScrcpy() {
        await this.execPromise('scrcpy');
    }
    async controller() {
        const ipAddresses = await this.getSanitizedIpAddresses();
        const result = await this.tryConnectionWithIpAddresses(ipAddresses);
        if (result)
            await this.runScrcpy();
        else
            console.log('Unable to connect to device!');
    }
}
const main = new Main();
main.controller();
