import * as util from 'util';
import { exec } from 'child_process';
import { readFile } from 'fs';

/*
    * TODO: The creator of scrcpy gave me a great tip on how to find the ip address
    * using: "adb shell netcfg" or "adb shell ip a", I will look into it
*/

class Main {
    /*
        * port can be passed as an argument through the command line
        * PORT=1234 node main.js
        * 
        * Also: The default port of adb is 5555, so if no port is passed
        * on the terminal, it will just be 5555.
    */
    private PORT: number | string = process.env.PORT || 5555;
    private execPromise = util.promisify(exec);
    private readFilePromise = util.promisify(readFile);

    constructor() {
        console.log(`Remote access called at: ${new Date()}\n`);
    }

    async getSanitizedIpAddresses(): Promise<string[]> {
        try {
            /*
                * DOCUMENTATION: 'https://angryip.org/documentation/'

                * [options] <feeder> <exporter>

                Where <feeder> is one of:
                -f:range <Start IP> <End IP>
                -f:random <Base IP> <IP Mask> <Count>
                -f:file <File>

                <exporter> is one of:
                -o filename.txt         Text file (txt)
                -o filename.csv         Comma-separated file (csv)
                -o filename.xml         XML file (xml)
                -o filename.lst         IP:Port list (lst)

                And possible [options] are (grouping allowed):
                -s      start scanning automatically
                -q      quit after exporting the results
                -a      append to the file, do not overwrite
            */

            // change the path for your system
            const pathToFile = './scan.txt';

            /*
                * This line will execute the scan with the ip range of:
                    * 10.0.0.0 to 10.0.0.255 ( it will look for the entire network )
                * the -f flag specifies the network range
                * the -s flag means the scan will start automatically
                * the -o flag specifies the path to save the output
                * the -q flag means the program should close automatically after the scan is done
                * 
                * the file is exported to 'scan.txt' inside this directory
                * which will be later read by the readFile function
            */
            await this.execPromise(`ipscan -f:range 10.0.0.0 10.0.0.255 -s -o ${pathToFile} -q`);

            /*
                * The scan file should look something like this: 

                Generated by Angry IP Scanner 3.7.2
                https://angryip.org

                Scanned 10.0.0.0 - 10.0.0.255
                23 de ago de 2020 10:31:09

                IP              Ping            Hostname                Ports           
                10.0.0.1        0 ms            _gateway                80              
                10.0.0.117      0 ms            230                     [n/a]           
                10.0.0.125      338 ms          Android.local           [n/a]           
                10.0.0.129      78 ms           [n/a]                   [n/a]           
                10.0.0.169      2 ms            [n/a]                   [n/a]           
                10.0.0.190      42 ms           [n/a]                   [n/a]

                * So there is quite a lot of cleaning and sanitizing to do.
            */
            const scanFile = await this.readFile(pathToFile);

            console.log(scanFile);

            const ipsInfo = scanFile.split('\n').filter(element => element.startsWith('10.0.0.'));
            /*
                * IpInfo should look something like this

                '10.0.0.1        0 ms            _gateway                80              ',
                '10.0.0.117      0 ms            230                     [n/a]           ',
                '10.0.0.169      37 ms           [n/a]                   [n/a]           '
            */

            const sanitizedIPS = ipsInfo.map(element => element.split(' ')[0]);
            /*
                * sanitizedIPS: ['10.0.0.1', '10.0.0.117', '10.0.0.169']
            */

            return sanitizedIPS;
        } catch (error) {
            console.error(error);
        }
    }

    async readFile(path: string): Promise<string> {
        try {
            const file = await this.readFilePromise(path, 'utf8');
            return file;
        } catch (error) {
            throw error;
        }
    }

    async connectToIpAddress(sanitizedIpAddresses: string[]): Promise<boolean> {
        try {
            for (let i = 0; i < sanitizedIpAddresses.length; i++) {

                /*
                    * sanitizedIpAddresses[i]: Nmap scan report for _gateway (10.0.0.1)
                    * But we need: 10.0.0.1
                    * 
                    * element.split(' '): ['Nmap', 'scan', 'report', 'for', '_gateway', '(10.0.0.1)']
                    * element.split(' ').length - 1: 5
                    * 
                    * ip: (10.0.0.1)
                    * sanitizedIp: 10.0.0.1
                */
                const element = sanitizedIpAddresses[i];
                const ip = element.split(' ')[(element.split(' ').length - 1)];
                const sanitizedIp = ip.replace(/[()]/g, '');

                const { stdout } = await this.execPromise(`adb connect ${sanitizedIp}:${this.PORT}`);

                // if it has already connected, there's no need to keep checking for open ports
                if (stdout.startsWith('connected')) return true;
            }

            return false;
        } catch (error) {
            console.error(error);
        }
    }

    async runScrcpy(): Promise<void> {
        await this.execPromise('scrcpy');
    }

    async controller(): Promise<void> {
        const ipAddresses = await this.getSanitizedIpAddresses();

        // const result = await this.connectToIpAddress(ipAddresses);
        // if (result) await this.runScrcpy();
        // else console.log('Something went wrong!');
    }
}

const main = new Main();
main.controller();
